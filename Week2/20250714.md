-----

## 오늘의 작업 리뷰

### ArrayAccessBenchmarkTest 작성

오늘은 Java에서 **`int[]`와 `List<Integer>`의 성능 차이**를 비교하는 벤치마크 코드를 작성하고 실행했습니다. 천만 개의 요소를 순차적으로 접근했을 때, `int[]`는 약 11ms가 걸린 반면, `List<Integer>`는 약 21ms가 소요되어 두 배 가까이 느리다는 것을 확인했습니다.

### 코드 (`ArrayAccessBenchmarkTest.java`)

```java
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class ArrayAccessBenchmarkTest {

    private static final int SIZE = 10_000_000;
    private static int[] primitiveArray;
    private static List<Integer> integerList;

    @BeforeAll
    static void setup() {
        // primitive 배열 초기화
        primitiveArray = new int[SIZE];
        for (int i = 0; i < SIZE; i++) {
            primitiveArray[i] = i;
        }

        // 박싱된 Integer 리스트 초기화
        integerList = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            integerList.add(i);
        }
    }

    @Test
    @DisplayName("Primitive int[] 순차 접근 벤치마크")
    void benchmarkPrimitiveArray() {
        long start = System.nanoTime();
        long sum = 0;
        for (int i = 0; i < primitiveArray.length; i++) {
            sum += primitiveArray[i];
        }
        long duration = System.nanoTime() - start;
        System.out.println("Primitive array time: " + duration / 1_000_000 + " ms");
        assertTrue(sum > 0);
    }

    @Test
    @DisplayName("List<Integer> 순차 접근 벤치마크")
    void benchmarkIntegerList() {
        long start = System.nanoTime();
        long sum = 0;
        for (int i = 0; i < integerList.size(); i++) {
            sum += integerList.get(i);  // unboxing 발생
        }
        long duration = System.nanoTime() - start;
        System.out.println("Boxed List<Integer> time: " + duration / 1_000_000 + " ms");
        assertTrue(sum > 0);
    }
}
```

### 작업 과정에서 배운 것

  * **캐시 지역성(Cache Locality)**: \*\*`int[]`\*\*는 메모리에 데이터가 연속적으로 저장되어 CPU 캐시의 \*\*'캐시 라인(Cache Line)'\*\*에 한 번에 여러 데이터가 로드됩니다. 덕분에 다음 데이터에 빠르게 접근할 수 있어 성능이 월등히 좋다는 것을 알게 되었습니다. 반면 \*\*`List<Integer>`\*\*는 객체 참조만 연속적으로 저장되고, 실제 `Integer` 객체는 힙 메모리의 여러 곳에 흩어져 있어 \*\*'캐시 미스(Cache Miss)'\*\*가 빈번하게 발생했습니다.
  * **메모리 접근 과정의 유사성**: `List<Integer>`의 접근 방식은 마치 MySQL의 InnoDB 엔진이 \*\*보조 인덱스(Secondary Index)\*\*를 통해 기본 키(Primary Key)를 찾고, 그 기본 키로 실제 레코드에 접근하는 과정과 유사하다는 것을 깨달았습니다. 둘 다 연속된 데이터(인덱스/참조)를 통해 흩어져 있는 실제 데이터(레코드/객체)에 다시 접근하는 이중 과정을 거친다는 공통점이 있습니다.

-----

## `SignUpResolver` 리팩토링

### 오늘 한 작업

기존의 `SignUpResolver` 클래스는 쿼리 파라미터를 직접 가져와서 유효성을 검증하는 방식이었습니다. 이 코드를 **`SignUpRequest`라는 불변(Immutable) 클래스를 도입**하여 개선했습니다. 이 리팩토링은 **[이펙티브 자바] 아이템 51: 메서드 시그니처를 신중히 설계하라**를 참고한 것으로, 원시 타입 매개변수가 너무 많을 때 객체로 묶어 처리하라는 조언을 적용한 것입니다. 이제는 `HttpRequestHolder`에서 직접 파라미터를 추출하는 대신, `SignUpRequest` 객체를 생성하여 모든 데이터를 담아 유스케이스 레이어로 전달합니다.

### 코드 (`SignUpResolver.java` 리팩토링 후)

```java
package webserver.resolver.response.get;

import java.util.Map;

import usecase.MemberUseCase;
import webserver.constant.HttpStatus;
import webserver.holder.request.HttpRequestHolder;
import webserver.holder.request.HttpRequestLine;
import webserver.holder.response.HttpResponseHolder;
import webserver.holder.response.VoidResponseHolder;

public class SignUpResolver { // 클래스 전체를 첨부하지 않기 위해 일부 수정

    private final MemberUseCase memberUseCase;

    public SignUpResolver(MemberUseCase memberUseCase) {
       this.memberUseCase = memberUseCase;
    }

    @Override
    public HttpResponseHolder response(final HttpRequestHolder requestHolder) {
       final HttpRequestLine requestLine = requestHolder.httpRequestLine();
       final Map<String, Object> queryParameters = requestLine.queryParameters();

       // 불변 클래스인 SignUpRequest를 생성하고 검증 로직을 위임
       final SignUpRequest signUpRequest = new SignUpRequest(queryParameters);

       memberUseCase.singUp(signUpRequest); // 변경된 메서드 시그니처
       return new VoidResponseHolder(requestHolder, HttpStatus.HTTP_200);
    }
}
```

### 작업 과정에서 배운 것

  * **불변 객체(Immutable Object)의 가치**: \*\*`SignUpRequest`\*\*와 같은 불변 객체를 사용하면 데이터의 안정성을 보장할 수 있고, 예기치 않은 데이터 변조를 막아줍니다.
  * **응집도 높은 객체 설계**: 기존에는 `SignUpResolver`가 파라미터 추출, 유효성 검증, 유스케이스 호출의 책임을 모두 가지고 있었습니다. 하지만 **`SignUpRequest` 클래스**를 도입하면서 **파라미터 매핑과 유효성 검증 로직을 이 객체 안으로 옮겨** 응집도를 높였습니다.
  * **명확한 의도 전달**: 원시 타입 파라미터를 여러 개 넘기는 대신, \*\*`memberUseCase.signUp(signUpRequest)`\*\*와 같이 **목적이 명확한 객체**를 넘기는 방식으로 메서드 시그니처를 변경했습니다. 이는 "회원가입에 필요한 데이터 묶음"을 전달한다는 의도를 명확히 표현해 코드를 읽는 사람에게 더 좋은 가이드 역할을 해줍니다.

-----

## KPT 회고

### Keep (유지할 점)
  * **실험 기반의 학습 방식**: 단순히 이론만 아는 것에 그치지 않고, 직접 **벤치마크 코드**를 작성해 눈으로 성능 차이를 확인한 점이 매우 좋았습니다.
  * **다른 기술과의 연관성 발견**: 자바의 리스트 성능 문제를 데이터베이스 인덱스 동작 방식과 연결해 생각한 것은 매우 의미 있는 사고 과정이었습니다.
  * **더 나은 방향을 고민하는 노력**: 단순히 이미 구현된 것에 만족하지 않고, **메서드 시그니처를 개선하는 등의 더 나은 방향을 계속 고민해 나가는 노력**은 앞으로도 계속 유지해야 할 중요한 태도입니다.

### Problem (문제점)
  * **초기 설계의 부재**: `SignUpRequest`의 필요성을 리팩토링 과정에서 깨달았습니다. 처음부터 이와 같은 \*\*DTO(Data Transfer Object)\*\*를 염두에 두고 설계했다면, 리팩토링 비용을 줄일 수 있었을 것입니다.
### Try (개선 방안)
  * **사전 모델링 습관화**: 앞으로는 기능 구현에 앞서 **어떤 데이터를 묶음으로 다룰지, 각 클래스의 책임은 어디까지일지**를 미리 모델링하는 습관을 들이겠습니다.

### 오늘 의사결정에 대한 자체 평가

오늘 의사결정에 대한 자체 평가
오늘의 의사결정은 '**단순한 호기심을 실제 경험으로 바꾸고, 더 나은 해결책을 고민하는 것**'으로 요약할 수 있습니다.
int[]와 List의 성능 차이에 대한 막연한 지식을 실제 코드로 검증하면서, 이론을 '**나의 경험**'으로 내면화할 수 있었습니다. 단순히 결과만 확인한 것이 아니라 '**왜 그럴까?**'라는 질문을 던지며 캐시 지역성과 메모리 접근 패턴이라는 근본적인 원리를 파악했습니다. 이 과정에서 자연스럽게 데이터베이스의 인덱스 접근 방식과 같은 다른 기술과의 유사점을 발견하며 지식을 확장할 수 있었습니다.

또한, 이미 구현된 SignUpResolver에 만족하지 않고, [**이펙티브 자바**]와 같은 서적을 참고하며 메서드 시그니처를 개선하는 등 더 나은 방향을 고민하고 개선해 나가는 과정 자체가 의미 있는 경험이었습니다.
물론 아직 부족한 부분도 많고, 더 깊이 있는 이해가 필요한 영역들이 있지만, 작은 호기심에서 시작해서 실제 검증과 개선으로 이어지는 이런 과정들이 쌓여가면서 조금씩 성장할 수 있을 것 같습니다.
