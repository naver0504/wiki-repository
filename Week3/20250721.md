## 오늘의 회고록

오늘 하루는 웹 애플리케이션의 **동적인 HTML 구현**에 집중하며 사용자 경험을 향상시키는 작업을 진행했습니다. 더불어, **LINE 기술 블로그**에서 **대규모 트래픽을 다루는 방법**, 특히 **벌크 인서트**에 대한 심도 있는 학습도 병행했습니다.

---

### 주요 학습 및 구현 내용

* **동적인 HTML 구현**
  
    사용자의 **로그인 상태에 따라 `/index.html`의 UI를 동적으로 변경**하는 기능을 구현했습니다.
    * **로그인 상태일 경우**: `/index.html`에 **사용자 이름**을 표시하고, 클릭하면 **개인정보 수정 페이지(`/mypage`)** 로 이동하도록 연결했습니다.
    * **로그인 상태가 아닐 경우**: `/index.html`에 **[로그인] 버튼**을 표시하고, `/mypage`와 같은 보호된 페이지 접근 시 **회원 가입 또는 로그인 페이지 등으로 리다이렉션** 처리했습니다.
* **LINE 오픈챗 서버의 트래픽 처리 방식 학습 (벌크 인서트)**
  
    LINE 기술 블로그의 **"LINE 오픈챗 서버가 100배 급증하는 트래픽을 다루는 방법"** 을 통해 대규모 트래픽 상황에서 발생하는 **MySQL의 성능 병목 현상과 해결책**을 학습했습니다.
  `INSERT ... SELECT ...`가 **벌크 인서트**로 취급되며, `innodb_autoinc_lock_mode`의 기본값(1, consecutive 모드)에서
  발생하는 **AUTO-INCREMENT 락 경합**이 대규모 동시 요청 시 심각한 성능 저하를 일으킬 수 있음을 이해했습니다.
  이를 **`innodb_autoinc_lock_mode`를 2(interleaved 모드)로 변경**하여 테이블 락 경합을 줄이고 동시 삽입 성능을 크게 향상시키는 해결 방안을 학습했습니다.

### 어려웠던 점

* **HTML 파일 파싱 문제**: HTML 파일을 동적으로 변경하는 과정에서 초기에는 단순히 `String` replace 방식으로 텍스트를 파싱하려 했습니다. 하지만 HTML 구조 내에 있는 **공백이나 특정 문자열 포함 여부** 등에 따라 의도한 대로 파싱이 제대로 되지 않는 문제가 발생했습니다.
* **HTML 동적 변경의 확장성 구현**: 단순히 `String` replace 방식으로는 HTML 구조가 복잡해지거나 동적으로 변경되어야 할 부분이 많아질수록 코드가 지저분해지고 유지보수가 어려워질 것이라는 한계를 느꼈습니다. 이러한 문제를 해결하고 **유연하고 확장성 있게 HTML을 동적으로 다루는 방법**을 찾는 것이 어려웠습니다. 최종적으로는 **Composite 패턴**을 활용하여 이 문제를 해결할 수 있었습니다.
* **MySQL AUTO-INCREMENT 락 동작 이해**: 단건 `INSERT` 시에는 `AUTO-INCREMENT` 락을 빠르게 획득하고 해제하는 방식으로 동작하는 줄로만 알았습니다. 하지만 **벌크 `INSERT` 시에는 락 획득 방식이 다르다**는 점을 몰라서 해당 내용을 이해하는 데 시간이 조금 더 필요했습니다.

---

### KPT

#### Keep (유지할 점)

* **일찍 출근하여 여유로운 준비 시간 확보**: 오늘처럼 일찍 출근하여 하루를 여유롭게 시작하고 업무 준비를 할 수 있었던 점은 매우 좋았습니다. 덕분에 집중력을 높여 학습과 구현에 임할 수 있었습니다.
* **확장성 있는 구조를 계속해서 고민하고 설계**: 단순한 기능 구현을 넘어, 복잡해질 수 있는 요구사항을 대비해 **확장성 있는 구조를 고민하고 설계해 나가는 노력**을 계속 유지할 것입니다.

#### Problem (문제점)

* **HTML 파일 파싱 및 동적 변경의 확장성 부족**: 위에서 언급했듯이, HTML 동적 변경 과정에서 `String` replace 방식의 한계를 경험했고, 유연하고 확장 가능한 구현에 대한 고민이 필요했습니다.
* **벌크 `INSERT` 시 `AUTO-INCREMENT` 락 동작에 대한 이해 부족**: 단건 `INSERT`와 벌크 `INSERT` 시 `AUTO-INCREMENT` 락 메커니즘이 다르다는 점을 미리 인지하지 못해 이해에 어려움을 겪었습니다.

#### Try (개선 방안)

* **디자인 패턴 활용 및 재사용성 고려**: HTML 동적 변경 문제 해결을 위해 **Composite 패턴을 활용**한 것처럼, 앞으로도 유사한 확장성 문제를 마주할 때 디자인 패턴을 적극적으로 탐색하고 적용하여 재사용 가능하고 유연한 코드를 작성하도록 노력하겠습니다.
* **세부 동작 메커니즘 심층 탐구**: 데이터베이스 락과 같이 중요한 시스템 컴포넌트의 동작 방식에 대해 단편적인 지식에 머무르지 않고, **다양한 상황에서의 세부적인 동작 메커니즘**까지 심층적으로 탐구하는 습관을 들이겠습니다.

---

### 학습 내용 상세

오늘 학습한 MySQL의 **`AUTO_INCREMENT` 락과 레코드 락**에 대한 내용은 다음과 같습니다. 이 두 가지 락은 서로 다른 목적을 가진 별개의 잠금 메커니즘이며, `innodb_autoinc_lock_mode` 설정에 따라 동작 방식이 크게 달라집니다.

* **`AUTO_INCREMENT` 락 (`AUTO-INC Lock`)**:
    * 이 락은 `AUTO_INCREMENT` 컬럼의 다음 값을 안전하게 할당하기 위한 잠금입니다.
    * **`innodb_autoinc_lock_mode = 1` (consecutive 모드, MySQL 5.x 기본값)**:
        * **단순 인서트 (Single Row Insert)**: 이 경우에는 테이블 수준의 `AUTO-INC` 락을 사용하지 않고, **뮤텍스(mutex)와 같은 경량 잠금(latch)** 을 사용합니다. 이 잠금은 `AUTO_INCREMENT` 값을 가져와서 할당하는 아주 짧은 순간에만 유지되어, 여러 트랜잭션이 동시에 단일 행을 삽입하더라도 큰 경합은 발생하지 않습니다.
        * **벌크 인서트 (Bulk Insert)**: `INSERT ... SELECT ...`와 같이 여러 행을 동시에 삽입하는 경우에는 `AUTO_INCREMENT` 값의 연속성을 보장하기 위해 **테이블 수준의 `AUTO-INC` 락**을 잡습니다. 이 락은 문장(statement)이 끝날 때까지 유지되어 동시 삽입 성능에 영향을 줄 수 있습니다.
    * **`innodb_autoinc_lock_mode = 2` (interleaved 모드, MySQL 8.0 기본값)**:
        * 이 모드에서는 모든 종류의 `INSERT` 문(단순, 벌크, 혼합 모드)이 **테이블 수준의 `AUTO-INC` 락을 사용하지 않습니다.** 모두 경량 잠금을 사용하여 `AUTO_INCREMENT` 값을 할당받으므로, 가장 높은 동시성을 제공합니다. 단, `AUTO_INCREMENT` 값의 연속성은 보장되지 않을 수 있습니다.
* **레코드 락 (Record Lock)**:
    * 레코드 락은 `AUTO_INCREMENT` 값 할당과는 별개로, 실제로 삽입되는 행(row) 자체의 데이터 무결성을 보호하기 위해 걸리는 잠금입니다.
    * `INSERT` 문이 실행되면 해당 트랜잭션은 새로 삽입되는 레코드에 대해 **배타 락 (Exclusive Lock, X-Lock)** 을 획득합니다. 이 락은 트랜잭션이 커밋되거나 롤백될 때까지 유지되어, 다른 트랜잭션이 해당 레코드를 수정하거나 삭제하는 것을 방지합니다.

**결론**: `AUTO_INCREMENT` 락과 레코드 락은 서로 다른 목적을 가진 별개의 잠금 메커니즘입니다. 오늘 학습한 문제 상황에서 발생했던 병목은 `INSERT ... SELECT`와 같은 벌크 인서트 구문이 `innodb_autoinc_lock_mode = 1`에서 테이블 수준의 `AUTO-INC` 락을 유발했기 때문이며, 이는 단일 행 삽입과는 다른 동작 방식입니다.
