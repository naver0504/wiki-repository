# Week1 HTTP 요청 파싱 및 정적 리소스 반환 구현 회고

## 구현 개요
오늘은 Week1의 HTTP 요청을 파싱하여 각각에 맞는 정적 리소스를 반환하는 기능을 구현했다.

## 구현한 것들

### 1. Holder 클래스 설계
먼저 요청과 응답에 관한 데이터를 담는 Holder 클래스들을 정의하고 구현했다.  
이는 `HttpServletRequest`와 `HttpServletResponse`와 비슷한 역할을 하는 객체들로, 각각의 HTTP 요청/응답 정보를 담고 있다.

### 2. 책임 분리 설계
- **Resolver**: 비즈니스 로직을 처리하는 역할  
- **ResponseHolder**: 비즈니스 로직으로 생성된 응답값을 보관하고, 이를 바이트로 변환하는 역할  

이렇게 각 클래스의 책임을 분리하여 설계했다.

#### 분리 이유
현재는 단순히 정적 리소스만을 반환하기 때문에 별다른 로직이 필요 없지만,  추후에 데이터베이스 접근이나 복잡한 비즈니스 로직을 처리해야 할 수도 있다.  
이러한 작업들은 Resolver에서 담당하고, ResponseHolder에서는 단순히 Resolver에서 처리한 결과물들을 보관하고 바이트로 변환하도록 책임을 분리했다.

또한, `ResponseHolder`를 인터페이스로 정의하고, 사용자가 원하는 응답 형태에 따라 구현체를 상속하도록 했다.  
현재는 정적 리소스만 반환하므로 `StaticResponseHolder` 객체를 이용해 HTML, CSS 등을 가져와 반환하도록 설계했다.

### 3. Record와 `final` 키워드 사용
**구현 방식**: 대부분의 클래스를 `record`로 선언하고, 파라미터를 `final`로 선언했다.

#### 선택 이유
토스 페이먼츠 과제 전형 코드에서 모든 파라미터가 `final`로 선언된 것을 참고하며 다음과 같은 장점을 발견했다:

- **불변성 보장**: `final` 선언으로 값 변경 방지  
- **컴파일타임 체크**: 실수로 변경 시 컴파일 오류 발생  
- **Record 특성**: 모든 필드가 `final`인 record와 일치  
- **코드 의도 명확화**: “이 값은 변경되지 않는다”는 의도를 명확히 표현  

이번 과제에서는 HTTP 요청/응답 데이터를 다룬다. 이런 데이터들은 한번 생성되면 변경될 이유가 없기 때문에 record와 final의 조합이 매우 적절하다고 판단했다.

## 고민한 것들

### 1. ResponseHolder의 책임 범위
ResponseHolder는 응답값을 보관하는 객체지만, 바이트 변환까지 처리하는 것이 맞는지 고민이 된다.

#### 두 가지 접근 방법
- **현재 방식**: ResponseHolder에서 바이트 변환까지 처리  
- **분리된 방식**: `ResponseTransformer` 인터페이스를 추가해 변환 책임 분리
  
### 결론
ResponseHolder는 이름 그대로 응답값만 보관하고, 바이트 변환은 별도 책임으로 분리해야 하나 고민된다.
분리할 시 역할을 너무 잘게 쪼개는 것 같기도 하고, 현재는 처리 로직이 많지 않아 과도한 추상화인 것 같아 현재 방식을 선택했다.

### 2. 인터페이스 상속의 필요성
```java
public interface ResponseResolver {
    HttpResponseHolder response(HttpRequestHolder requestHolder);
    boolean supports(HttpRequestHolder httpRequestHolder);
}

public interface GetResponseResolver extends ResponseResolver {
    // 현재 추가 메서드 없음
}
````

단순 상속만으로 추가 메서드가 없고, 네이밍만을 위해 인터페이스를 추가하는 것은 적절한지 고민된다.

#### 내가 생각한 장단점
* **장점**: 코드를 읽는 사람이 해당 클래스의 역할을 명확히 알 수 있음. 또한, 향후 GET 요청 전용 메서드가 필요하다면 이 구조가 유용할 것
* **단점**: 현재로선 추가 기능이 없어 네이밍만을 위해 인터페이스를 추가하는 것은 불필요할 수 있음

### 결론
추후에 GET을 제외한 다른 요청도 처리할 것 같고 GET에도 추가적인 메서드가 필요할 가능성이 높다고 판단했다. 
또한, 네이밍만으로 이 객체의 역할을 알 수 있다는 점이 이 클래스가 어떤 역할을 하는지 명확하게 알 수 있다는 것은 큰 장점이라 생각해 유지하기로 했다.
