# Week 1 웹서버 스레드 풀 선택 회고

## 1. 구현 개요
정적 파일(HTML/CSS)을 내려주는 간단한 웹서버를 구현하며, 클라이언트 요청을 처리할 스레드 풀을 선택해야 했다.  
현재 서버 구동부(`WebServer.java`)는 다음과 같다:

```java
public class WebServer {
    private static final int DEFAULT_PORT = 8080;
    private static final int CURRENT_CORE = 10;
    // Fixed Thread Pool
    private static final ExecutorService threadPool = Executors.newFixedThreadPool(CURRENT_CORE);
    // ForkJoinPool 대안
    // private static final ExecutorService threadPool = new ForkJoinPool(CURRENT_CORE);
    
    public static void main(String[] args) throws Exception {
        int port = (args.length == 0 ? DEFAULT_PORT : Integer.parseInt(args[0]));
        try (ServerSocket listenSocket = new ServerSocket(port)) {
            while (true) {
                Socket connection = listenSocket.accept();
                threadPool.submit(new RequestHandler(connection));
            }
        }
    }
}
````

## 2. 설명

* **FixedThreadPool**
  `Executors.newFixedThreadPool(n)` 은 고정 개수(`n`)의 스레드를 재사용하며, 모든 스레드가 바쁠 경우 작업은 내부 큐에 대기시킨다.
* **ForkJoinPool**
  `ForkJoinPool` 은 **work-stealing**을 지원하여, 유휴 스레드가 바쁜 스레드의 큐에서 작업을 훔쳐 처리하도록 최적화되어 있다.주로 분할·정복(fork/join) 스타일 작업에 적합하다.

## 3. 예상

단순 I/O(정적 파일 읽기/내보내기) 중심이므로, `FixedThreadPool`이 더 빠를 것이라 판단했다.

## 4. 벤치마크 결과 (50,000 요청, 풀 크기 = 10)

| Pool 종류             | # Samples | Average (ms) | Min (ms) | Max (ms) | Std Dev (ms) | Throughput (req/sec) |
| ------------------- | --------- | ------------ | -------- | -------- | ------------ | -------------------- |
| **FixedThreadPool** | 50,000    | **3**        | 0        | 369      | 20.21        | 9,360                |
| **ForkJoinPool**    | 50,000    | **12**       | 0        | 1,147    | 68.15        | 7,797                |
| *(JMeter 결과 요약)*    |           |              |          |          |              |                      |

## 5. 결론 및 이유

### 5.1 결과 요약

* **FixedThreadPool**: 평균 3ms, 처리량 9,360 req/sec
* **ForkJoinPool**: 평균 12ms, 처리량 7,797 req/sec
* **성능 차이**: FixedThreadPool이 약 **4배 빠른 응답시간**과 **20% 높은 처리량**을 보임

### 5.2 ForkJoinPool이 느린 이유
ForkJoinPool은 작업 분할(fork/join)과 work-stealing 큐 관리 로직을 수행하지만,  I/O 바운드 환경에서 스레드가 파일 I/O 중 `WAITING` 상태에 들어가면
work-stealing 전략 자체가 무의미해진다. 결국 불필요한 스케줄링·큐 관리 오버헤드만 추가되어 성능이 떨어진다.

### 결론
대부분의 WAS(Spring Boot, Tomcat 등)는 DB 접근 등 I/O 바운드 작업이 주류이며, 벤치마크에서도 FixedThreadPool이 더 우수한 성능을 보여주었다. 따라서 이번 과제에서는 **FixedThreadPool**을 사용하기로 결정했다.  


## 6. 최적의 PoolSize 분석

### 6.1 최적 크기 결정 요인

* **I/O 바운드 작업의 특성**

  * 이론적 최적 크기는`CPU 코어 수 × (1 + I/O 대기시간/CPU 처리시간)`이다. 즉, 정적 파일 서버의 경우 I/O 대기 비율이 높아 코어 수보다 많은 스레드 필요함.

### 6.2 벤치마크 결과 (50,000 요청, I/O 바운드 정적 파일 서버)

| Pool 크기 | # Samples | Average (ms) | Min (ms) | Max (ms) | Std Dev (ms) | Throughput (req/sec) |
| ------- | --------- | ------------ | -------- | -------- | ------------ | -------------------- |
| **10**  | 50,000    | 3            | 0        | 369      | 20           | 9,360                |
| **13**  | 50,000    | 5            | 0        | 420      | 35           | 9,000                |
| **15**  | 50,000    | 3            | 0        | 187      | 15           | 9,014                |
| **20**  | 50,000    | 6            | 0        | 619      | 40           | 8,000                |



### 6.3 결과 분석

반복 테스트 결과 10 > 13, 15 > 10, 13 > 20 으로 뒤죽박죽 성능이 나왔는데, 계속된 벤치마크 수행으로 노트북에 부하가 걸리면서 정확도가 떨어진 영향인 것 같다.
풀 크기를 15로 올려볼 수도 있지만, 단순한 I/O 바운드 작업이 주를 이루니 굳이 늘리지 않고 **기본 논리 프로세서 수(10)를 그대로 사용**하기로 했다.
